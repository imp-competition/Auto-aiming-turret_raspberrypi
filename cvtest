from picamera2 import Picamera2
import cv2 as cv
import numpy as np
import time
import math
import serial

# 위 아래로 서보모터 45~180도로 제한 둔 코드

# ---------- Config ----------
HFOV_DEG = 66.0     # 카메라 가로 시야각 0번
VFOV_DEG = 41.0     # 카메라 세로 시야각 3번

FRAME_W, FRAME_H = 1280, 720        # 카메라의 해상도는 1280x720
TARGET_FPS = 30                     # FPS

MIRROR = True

# size filter as fraction of full image area (tunable)
# 추적할 물체의 크기 범위를 정함. 화면 전체 면적의 몇 퍼센트(0.05%~20%) 크기인
# 물체만 추적할지 정함. 너무 작은 노이즈나 너무 큰 배경은 무시하기 위함
AREA_FRAC_MIN = 0.0005   # ~0.05% of frame area
AREA_FRAC_MAX = 0.20     # ~20% of frame area

# 원형도의 최솟값 / 풍선처럼 둥근 물체를 추적
# 얼마나 둥근 형태인지 (값이 1.0에 가까울수록 완전한 원)
CIRC_MIN = 0.90          # 현실 풍선 고려(너무 빡빡 X)

# morphology
OPEN_K = 5
CLOSE_K = 7
OPEN_ITERS = 1
CLOSE_ITERS = 2

# angle/motor
# SMOOTH_ALPHA : 물체의 움직임을 부드럽게 만드는 평활화
# 값이 높을수록 최근 움직임에 더 크게, 낮을수록 과거 움직임도 고려하여 천천히 움직임
SMOOTH_ALPHA = 0.4
MIN_MOVE_DEG = 1.0
# 카메라의 중심에서 물체가 몇 픽셀 이내에 있으면 움직이지 않도록 하는 무감대
DEADZONE_PX  = 8
RANGE_CM     = 200.0
H_CM_PER_DEG = 1.32
V_CM_PER_DEG = 1.32

# UART (팬=ttyAMA0, 틸트=ttyAMA3)
# 서보모터 제어위한 UART(시리얼 통신) 설정 / 팬모터, 틸트모터가 각각 연결
UART_PAN  = '/dev/ttyAMA2'
UART_TILT = '/dev/ttyAMA3'
BAUDRATE  = 115200
SER_TIMEOUT = 0.1

# ---------- 서보(0~180) 전송용 설정 ----------
SERVO_MIN = 0
SERVO_MAX = 180
SERVO_CENTER_PAN  = 90   # 팬 서보 중립
SERVO_CENTER_TILT = 90   # 틸트 서보 중립
SIGN_PAN  = +1           # 방향 반전 필요하면 -1로
SIGN_TILT = -1           # 방향 반전 필요하면 -1로

# ★ 추가: 축별 한계값 (요구사항: 틸트만 45~180으로 제한)
PAN_MIN,  PAN_MAX  = 0, 180
TILT_MIN, TILT_MAX = 75, 180

# ---------- Color masking (wider red + dual thresholds + optional V-CLAHE) ----------
def make_mask_from_bgr(frame_bgr, use_clahe=True):
    hsv = cv.cvtColor(frame_bgr, cv.COLOR_BGR2HSV)

    if use_clahe:
        h, s, v = cv.split(hsv)
        clahe = cv.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
        v = clahe.apply(v)
        hsv = cv.merge([h, s, v])

    def or_ranges(hsv_img, ranges):
        m = None
        for lo, hi in ranges:
            cur = cv.inRange(hsv_img, np.array(lo), np.array(hi))
            m = cur if m is None else cv.bitwise_or(m, cur)
        return m

    # Red: extend hue and add a darker fallback
    red_bright = [((0,130,80),(15,255,255)), ((165,130,80),(180,255,255))]
    red_dark   = [((0, 90,40),(15,255,255)), ((165, 90,40),(180,255,255))]
    m_red = cv.bitwise_or(or_ranges(hsv, red_bright), or_ranges(hsv, red_dark))

    mask = m_red

    # morphology to close patterns/holes
    k_open  = cv.getStructuringElement(cv.MORPH_ELLIPSE, (OPEN_K, OPEN_K))
    k_close = cv.getStructuringElement(cv.MORPH_ELLIPSE, (CLOSE_K, CLOSE_K))
    mask = cv.morphologyEx(mask, cv.MORPH_OPEN,  k_open,  iterations=OPEN_ITERS)
    mask = cv.morphologyEx(mask, cv.MORPH_CLOSE, k_close, iterations=CLOSE_ITERS)
    return mask

# ---------- Geometry/selection ----------
def circularity_from_contour(cnt):
    area = cv.contourArea(cnt)
    perim = cv.arcLength(cnt, True)
    if perim <= 0:
        return 0.0, area
    circ = 4.0 * math.pi * area / (perim * perim)
    return circ, area

def pick_best_target(mask, frame_area_min, frame_area_max, circ_min):
    cnts, _ = cv.findContours(mask, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)
    best = None

    for c in cnts:
        hull = cv.convexHull(c)
        circ, area = circularity_from_contour(hull)

        if area < frame_area_min or area > frame_area_max:
            continue
        if circ < circ_min:
            continue

        x, y, w, h = cv.boundingRect(hull)
        M = cv.moments(hull)
        if M["m00"] == 0:
            continue
        cx = int(M["m10"] / M["m00"])
        cy = int(M["m01"] / M["m00"])

        cand = {
            "score": circ,
            "circularity": circ,
            "area": int(area),
            "bbox": (x, y, w, h),
            "center": (cx, cy),
            "hull": hull
        }
        if (best is None) or (cand["score"] > best["score"]) or \
           (abs(cand["score"] - best["score"]) < 1e-6 and cand["area"] > best["area"]):
            best = cand
    return best

def px_to_deg(dx_px, dy_px, width, height):
    deg_x = (dx_px / float(width))  * HFOV_DEG
    deg_y = (dy_px / float(height)) * VFOV_DEG
    return deg_x, deg_y

def angle_to_cm(deg_x, deg_y, range_cm):
    dx_cm = range_cm * math.tan(math.radians(deg_x))
    dy_cm = range_cm * math.tan(math.radians(deg_y))
    return dx_cm, dy_cm

def cm_to_motor_deg(dx_cm, dy_cm):
    need_deg_x = dx_cm / H_CM_PER_DEG
    need_deg_y = dy_cm / V_CM_PER_DEG

    def quantize(v):
        s = 1 if v >= 0 else -1
        mag = abs(v)
        if mag < MIN_MOVE_DEG:
            return 0
        return int(round(s * mag))

    return quantize(need_deg_x), quantize(need_deg_y)

# ---------- 상대각(±) → 서보 절대각(0~180) ----------
def delta_to_servo_angles(cmd_deg_x, cmd_deg_y):
    # 방향 반전은 SIGN_*로 제어
    pan  = SERVO_CENTER_PAN  + SIGN_PAN  * cmd_deg_x
    tilt = SERVO_CENTER_TILT + SIGN_TILT * cmd_deg_y

    # ★ 변경: 축별 한계로 클램프
    pan  = max(PAN_MIN,  min(PAN_MAX,  int(pan)))
    tilt = max(TILT_MIN, min(TILT_MAX, int(tilt)))
    return pan, tilt

# ---------- UART helpers ----------
class MotorUART:
    def __init__(self, port_pan, port_tilt, baud, timeout):
        self.ser_pan  = serial.Serial(port_pan,  baud, timeout=timeout)
        self.ser_tilt = serial.Serial(port_tilt, baud, timeout=timeout)
        time.sleep(0.2)  # 포트 안정화 약간 대기
        self.last_pan_angle  = None  # 0~180 절대값 캐시
        self.last_tilt_angle = None

    def send_servo(self, pan_angle, tilt_angle):
        """서보 각도(0~180) 정수 문자열로 각각의 포트에 전송. 변화 있을 때만 전송."""
        # ★ 변경: 축별 한계로 한 번 더 보정 (하드웨어 보호용 이중 안전장치)
        pan_angle  = max(PAN_MIN,  min(PAN_MAX,  int(pan_angle)))
        tilt_angle = max(TILT_MIN, min(TILT_MAX, int(tilt_angle)))

        if pan_angle != self.last_pan_angle:
            self.ser_pan.write(f"{pan_angle}\n".encode('ascii'))
            self.last_pan_angle = pan_angle

        if tilt_angle != self.last_tilt_angle:
            self.ser_tilt.write(f"{tilt_angle}\n".encode('ascii'))
            self.last_tilt_angle = tilt_angle

    def close(self):
        for s in (self.ser_pan, self.ser_tilt):
            try:
                s.close()
            except:
                pass

# ---------- Main (Picamera2 + UART) ----------
def main():
    motors = MotorUART(UART_PAN, UART_TILT, BAUDRATE, SER_TIMEOUT)

    picam2 = Picamera2()
    config = picam2.create_preview_configuration(main={"size": (FRAME_W, FRAME_H)})
    picam2.configure(config)
    picam2.start()

    cx0, cy0 = FRAME_W // 2, FRAME_H // 2
    ema_cx, ema_cy = None, None

    frame_area = FRAME_W * FRAME_H
    AREA_MIN = int(AREA_FRAC_MIN * frame_area)
    AREA_MAX = int(AREA_FRAC_MAX * frame_area)

    prev_t = time.time()
    fps = 0.0

    try:
        while True:
            frame_rgb = picam2.capture_array()
            frame = cv.cvtColor(frame_rgb, cv.COLOR_RGB2BGR)
            if MIRROR:
                frame = cv.flip(frame, 1)

            mask = make_mask_from_bgr(frame, use_clahe=True)
            target = pick_best_target(mask, AREA_MIN, AREA_MAX, CIRC_MIN)

            vis = frame.copy()
            cv.drawMarker(vis, (cx0, cy0), (255, 255, 255), markerType=cv.MARKER_CROSS, markerSize=24, thickness=2)
            cv.circle(vis, (cx0, cy0), 3, (0, 0, 255), -1)
            if MIRROR:
                cv.putText(vis, "MIRROR: ON", (FRAME_W - 180, 30), cv.FONT_HERSHEY_SIMPLEX, 0.7, (200, 200, 255), 2)

            if target is not None:
                (bx, by, bw, bh) = target["bbox"]
                (cx, cy) = target["center"]
                area = target["area"]
                circ = target["circularity"]
                hull = target["hull"]

                if ema_cx is None:
                    ema_cx, ema_cy = cx, cy
                else:
                    ema_cx = int(SMOOTH_ALPHA * cx + (1 - SMOOTH_ALPHA) * ema_cx)
                    ema_cy = int(SMOOTH_ALPHA * cy + (1 - SMOOTH_ALPHA) * ema_cy)

                dx_px = ema_cx - cx0
                dy_px = ema_cy - cy0

                # 데드존
                if abs(dx_px) < DEADZONE_PX:
                    dx_px = 0
                if abs(dy_px) < DEADZONE_PX:
                    dy_px = 0

                # 픽셀 → 각도
                deg_x, deg_y = px_to_deg(dx_px, dy_px, FRAME_W, FRAME_H)
                # 각도 → 거리(cm)
                dx_cm, dy_cm = angle_to_cm(deg_x, deg_y, RANGE_CM)
                # 거리 → 필요한 상대 회전각(±)
                cmd_deg_x, cmd_deg_y = cm_to_motor_deg(dx_cm, dy_cm)
                # 상대각(±) → 서보 절대각(0~180) + 축별 한계 클램프
                servo_pan, servo_tilt = delta_to_servo_angles(cmd_deg_x, cmd_deg_y)

                # UART 전송 (항상 0~180 전송, 이중 안전장치로 축별 한계 적용)
                motors.send_servo(servo_pan, servo_tilt)

                # --- 시각화 ---
                cv.rectangle(vis, (bx, by), (bx + bw, by + bh), (0, 255, 0), 2)
                cv.circle(vis, (ema_cx, ema_cy), 5, (0, 0, 255), -1)
                cv.drawContours(vis, [hull], -1, (255, 0, 255), 2)

                y0 = 28
                dy = 28
                cv.putText(vis, f"area:{area}  circ:{circ:.3f}  score:{target['score']:.3f}",
                           (bx, max(0, by - 10)), cv.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)
                cv.putText(vis, f"offset_px:   ({dx_px:+d}, {dy_px:+d})",
                           (10, y0), cv.FONT_HERSHEY_SIMPLEX, 0.7, (50, 220, 50), 2)
                cv.putText(vis, f"offset_deg:  ({deg_x:+.2f}, {deg_y:+.2f})",
                           (10, y0+dy), cv.FONT_HERSHEY_SIMPLEX, 0.7, (50, 220, 50), 2)
                cv.putText(vis, f"offset_cm*:  ({dx_cm:+.1f}, {dy_cm:+.1f})  @R={RANGE_CM:.0f}cm",
                           (10, y0+2*dy), cv.FONT_HERSHEY_SIMPLEX, 0.7, (50, 220, 50), 2)
                cv.putText(vis, f"motor_cmd:   panΔ={cmd_deg_x:+d}°, tiltΔ={cmd_deg_y:+d}°",
                           (10, y0+3*dy), cv.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 255), 2)
                cv.putText(vis, f"servo_out:   pan={servo_pan:3d}°, tilt={servo_tilt:3d}° (0~180)",
                           (10, y0+4*dy), cv.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 255), 2)
            else:
                ema_cx = ema_cy = None
                cv.putText(vis, "No target", (10, 30), cv.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)
                # 타깃 없을 때 중립 복귀하고 싶으면 아래 한 줄 활성화
                # motors.send_servo(SERVO_CENTER_PAN, SERVO_CENTER_TILT)

            now = time.time()
            dt  = now - prev_t
            prev_t = now
            if dt > 0:
                fps = 0.9 * fps + 0.1 * (1.0 / dt) if fps > 0 else (1.0 / dt)
            cv.putText(vis, f"FPS: {fps:.1f}", (10, FRAME_H - 10),
                       cv.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 0), 2)

            cv.imshow("frame", vis)
            cv.imshow("mask", mask)

            key = cv.waitKey(1) & 0xFF
            if key == 27 or key == ord('q'):
                break
    except KeyboardInterrupt:
        print("Interrupted.")
    finally:
        cv.destroyAllWindows()
        picam2.stop()
        motors.close()

if __name__ == "__main__":
    main()
